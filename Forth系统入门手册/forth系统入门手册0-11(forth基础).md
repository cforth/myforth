##第0章 前言

######作者：ear
######日期：2010.10

这是一本游戏手册，是的，你没听错，因为forth不能给你带来显而易见的实际利益，几乎没什么公司招聘forth程序员，forth太冷门了（至少目前是这样），所以你只能把它当成一个游戏来玩。

在推销一件东西的时候，吹嘘它的优点是必须的，虽然以往对forth吹得天花乱坠的溢美词很多，但是冷门还是冷门。所以我也懒得吹了，简单说说它的优缺点吧

优点:

1. 语法极其简单，你找不出比它更简单的语法了；
2. 它具有底层语言和高级语言的特性，理论上来说，可以用在任何领域，但由于库函数不多，所以更适用于嵌入式；
3. 容易适应不同的软硬件（可移植性好）；
4. 运行速度接近于C；
5. 高度模块化，结构小巧紧凑；
6. 生成的可执行程序尺寸只比汇编大；
7. 可即时进行函数单元测试；
8. 非常自由，可自定义语法。


缺点:

1. 使用后缀表达式，让习惯主流语言的人不太适应；
2. 太过自由，容易造成混乱，开发者们的力气拧不到一块儿去，只有一个最基本的forth ANSI标准，尽管如此，还不是每个版本的forth都支持这个标准；
3. 对程序员自身的思维能力要求比较高，这也是自由的双刃剑；
4. 缺少足够的函数库，需要重新发明轮子；
5. 没有一个用forth开发的足够成熟的PC操作系统（嵌入式的倒是不少）；
6. 使用者稀少。

其实forth是从一种高度模块化的汇编编程风格演变而来的，forth保留了这种风格的子程序列表方式，并增加了以堆栈做为子程序参数传递的公共接口，为此还衍生了一些专门操作堆栈的子程序。所以说，forth的基础就是堆栈和词典，它的根本思想是高度模块化和模块之间便于传递参数的公共接口，在这个基础上，forth也衍生出了一些独有的特性。

本文的目标是让那些有一定编程经验、但是对forth和汇编毫无概念的业余爱好者也能看得懂。本手册的内容包括了forth的基本概念、语法，用C编写的forth编译器的简单模型，以及用汇编从无到有构造一个forth编译器。本人水平有限，写此文的目的除了引导新手，更多的是想抛砖引玉砸出一些高手。

本文主要是以eforth(附件)为例，理由是它很小很简陋，gforth也可以，就是大了点。这里是其他版本的forth编译器http://www.forth.org/compilers.html

需要说明的一点是，它们的词典标准不一定一样。


##第1章 简单的语法

还记得以前我们是怎样学英文的吗？现在来回顾一下吧

    he is a bold man
    he ：他
    is ：是
    a ：一个
    bold ：
    man ：人

我不认得bold这个单词，怎么办？聪明好学的同学提供了一个方法，查词典。OK，那就查吧。

    bold：大胆的

好了，现在我知道怎么翻译了，他就是一个胆儿肥的人。以后再遇到不懂的单词，我就知道该去查词典了。

英文是这样，中文也是这样，碰到不懂的字，我们就会去查词典，弄清这个句子里所有的字是什么意思的时候，我们也就完全明白这个句子是什么意思了。

让我们继续翻译

    he is a sdf man

sdf：胆大的；是bold的同义词

“sdf???你瞎编的吧？”没错，就是瞎编的，而且我还成功忽悠了刚刚学英语的小朋友，这让我很有成就感！但是大朋友们就不那么好忽悠了，他们会用怀疑的目光看着我，然后转过头去翻词典，这让我很没成就感！

为了将忽悠进行到底，我决定贿赂该词典的出版社，让他们把我瞎编的词收录到他们的词典里，然后自掏腰包出版新词典。这样一来，当大朋友们在词典上查不到sdf时，我会告诉他们说，他们用的是过了期的词典，然后递给他们一本我自费出版的新词典，再然后。。。他们全信了！这让我的虚荣心得到了极大的满足，哈哈哈哈哈！现在，我可以在跟别人沟通交流时毫无障碍的使用sdf这个“流行词”了！

以上所说的就是forth里最基本的内容：字，词典，定义字。forth里有几十个最基本的字，它们被人称作code字、核心词、原语等等等等。下一个阶层的字则是由这些最基本的字或本阶层的字组合而成，被称作colon字、扩展词、冒号字等等等等。拿上面的英文句子举个例子：

输入：

    : he	." 他" ;
    : is	." 是" ;
    : a		." 一个" ;
    : bold	." 胆大的" ;
    : sdf	bold ;
    : man	." 人" ;
    he is a sdf man 

屏幕显示：

    他是一个胆大的人

需要说明的一点就是`: bold`必须在`: sdf`之前，否则forth会告诉你没有`sdf`这个字。

forth的语法就是按顺序执行每一个字，碰到词典里没有的字的时候，就给出提示，并终止运行，这语法够简单吧？

`:（冒号）`是一个用来定义一个新字的字，`;(分号)`是一个表示定义语句结束的字，`.`是一个用于输出字符串的字，与输出内容用空格隔开。在forth里面，“有且只有”字，这保证了forth整体上的统一性。如果还要再算上一个，那就是空格，它是使用频率最高的符号，用于区分字与字。

有人要问了，为什么要把冒号放在前头，这不是完全违反了人类的语法习惯？我的回答是，forth这种反人类反社会的语法不是专门给人看的，是给机器看的，但是人也能看懂。就像听老外说中国话，虽然他时不时的语无伦次，但你也能听懂他说的是什么意思。


另一个反人类的语法

    1+2=？

如果你这样询问forth，它会告诉你没有“1+2=?”这个字。那么应该怎么问呢？是这样的，问它“1 2 + .”（“.”是输出十进制数值），然后它会告诉你“3”，再然后你又该骂它反人类反社会了，╮(╯_╰)╭我想我不需要再重复的解释理由了吧？


##第2章 forth机的基本结构

大家都知道堆栈吧？先进先出的堆和先进后出的栈。什么？你不知道？嗯，内事问百度。什么，你连百度都不想问？你太懒了，我很不喜欢除了自己以外的懒人。


主流编程语言习惯,由编译器自动分配释放栈区（stack） ，存放函数的参数值，局部变量的值等。而堆区（heap） 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。

而forth机的本质就是先进后出的堆栈机（stack computer），很少用到堆，它有两个栈，一个是嵌套调用函数（也就是字）的返回栈（return stack），另一个是存放局部变量的数据栈（data stack）

区别是什么？主流语言需要定义变量，给变量起名，还要考虑这名字好不好懂，会不会跟其他变量名重复。forth不是这样，它需要起名的只有字（函数），而局部变量都是只标明是什么类型的无名变量。某人要问了，没名字的变量怎么调用？嗯，这就是堆栈所要发挥的作用了，我只需要把这些参数按调用的先后顺序扔到堆栈上，然后逐一调用即可。某人继续问，万一函数里的无名参数太多呢，怎么记得住？嗯，多了是记不住，但是为什么要把那么多参数放在一个函数里，你就不会拆分成几个函数，让每个函数只处理1到3个参数吗？让每个函数做好自己的事，各行其职，整个程序不就全都和谐美好了吗？

话题扯远了，继续说stack，上一章的`1+2=3`在堆栈上的表现是这样的：

     1 2 + .
     1（放入1）
    ┏━━━
    ┃①
    ┗━━━
    2（放入2）
    ┏━━━
    ┃①②
    ┗━━━
    +（先取出2，再取出1，计算得3，然后放入stack）
    ┏━━━
    ┃①         ②
    ┗━━━
    ┏━━━
    ┃            ①②
    ┗━━━
    ┏━━━
    ┃             ③
    ┗━━━
    ┏━━━
    ┃③
    ┗━━━
    .（取出并显示3）
    ┏━━━
    ┃
    ┗━━━

stack的先入后出就是这样





##第3章 算术练习题1

为了加深你对stack的理解，来几道小学生程度的算术题，以forth的方式，答案在下章结尾。

    第1题    1+2+3+4
    第2题    1+2-3+4
    第3题    1+2*3+4
    第4题    （1+2）*（3+4）




##第4章 算术练习题2

不知道你有没有发觉，上一章你输入数据的顺序和你用笔在纸上计算的顺序是一样，这不是巧合，这只是你思路的顺序，而forth只是遵照你的思路在执行。可以这样说，forth只是你思维的延续，你本人能解决的问题，forth就一定能解决，只要你能清晰的剖析自己的思路；但如果连你自己都解决不了，也就别指望forth能帮你解决了。

上一章的答案

    第1题    1 2 + 3 + 4 + .
    第2题    1 2 + 3 - 4 + .
    第3题    2 3 * 1 + 4 + .
    第4题    1 2 + 3 4 + * .


接下来就是中学水平的计算题了

    示例1： Y=X+5  输入某个数X，求Y
    解：X 5 +
    示例2： Y=a+b*(c+5)  输入某个数X，求Y
    解：c 5 + b * a +
    练习题
    Y = 12 + ((93 * a / 2 + 432*b)/129+c)*2
    
答案在下章


##第5章 算术练习题3

第1种答案：

    93 a * 2 /
    432 b * 
    + 129 / 
    c + 2 * 12 + 



第2种答案：

还记得之前瞎编的那个同义词吗？

    : func_a	93 * 2 / ;
    : func_b	432 * ;
    : func_ab	+ 129 / ;
    : func_c	+ 2 * 12 + ;
    a func_a b func_b  func_ab  c func_c 

你是不是觉得第二种方法比第一种更麻烦？既然这样，我这里有3组数据

    a=2, b=4, c=6
    a=3, b=4, c=5
    a=1, b=3, c=6
    
我用第二种方法算，你用第一种方法算，咱们看看谁算得快。

我只需要输入一遍

    : func_a	93 * 2 / ;
    : func_b	432 * ;
    : func_ab	+ 129 / ;
    : func_c	+ 2 * 12 + ;
    a func_a b func_b  func_ab  c func_c 
    
再输入三遍

    a func_a b func_b  c func_c 
    
就可以了。

你就老老实实的把那一连串的字符输入三遍吧！

思考题

虽然我输入的字符比较少，但是如果数据成百上千，那工作量也够大的，能不能让输入的工作量再少点？





##第6章 先入后出的stack

第二种解法重复输入的时候需要输入3个参数和3个自定义的字，3个参数是必不可少的，3个定义字却还能再简化成1个定义字，所以我打算做成a b c func_y，那么输入a b c之后

    ┏━━━
    ┃a b c
    ┗━━━

按照算式的逻辑，我们应该先从a开始算起，但是，c却把出口堵住了，再瞄了一下c的后面，b也不是什么好鸟。没办法，我只好亲自协管一下，我就不信我不能把这事给管斜了。让a享受最高待遇，让c去垫底，让b夹当中。嗯，现在看起来和谐多了

    ┏━━━
    ┃c b a 
    ┗━━━

首先是a

    : func_a	93 * 2 / ;
    假设a func_a计算得出A
    ┏━━━
    ┃c b A
    ┗━━━

然后轮到b了，但是这时候A又开始堵门了。还要协管吗？可A是算出来的，不能像刚开始那样直接协管了。

还记得forth一共有两个stack吗？我们之前一直在用的是数据栈（data stack），而现在我们就要用到返回栈（return stack）了。操作字是r>和>r（注：eforth的系统命令都是大写字母），这字义很形象吧，不用我解释了吧？

    先把大A从DS扔到RS上，然后我们再来收拾小b
    >r
    DS
    ┏━━━
    ┃c b 
    ┗━━━
    RS
    ┏━━━
    ┃A
    ┗━━━

    : func_b	432 * ;
    b func_b
    DS
    ┏━━━
    ┃c B 
    ┗━━━

    接下来把A拉回来
    r>
    DS
    ┏━━━
    ┃c B A
    ┗━━━
    RS
    ┏━━━
    ┃
    ┗━━━

    再让A、B合体
    : func_ab	+ 129 / ;
    B A func_ab
    DS
    ┏━━━
    ┃c [AB]
    ┗━━━

    最后就轮到我们仅存的未经处理的小c了
    : func_c	+ 2 * 12 + ;
    ┏━━━
    ┃C
    ┗━━━

完整的程序

    : func_a	93 * 2 / ;
    : func_b	432 * ;
    : func_ab	+ 129 / ;
    : func_c	+ 2 * 12 + ;
    : func_y	func_a >r func_b r> func_ab func_c ;
    c b a func_y


如果我想用 a b c func_y的这种写法呢?这个问题给你去想





##第7章 栈顶单元的使用规则和注释

forth在使用栈顶单元的时候有个规则，就是每个单元只能使用一次，使用过后就会被抹去，例如

    1
    ┏━━━
    ┃1
    ┗━━━
    .（显示1）
    ┏━━━
    ┃
    ┗━━━

所以在定义一个新字的时候，通常会给这个字加以注释

    ( n --  )
    : .	 ~~~~ ;
    
    ( n1 n2 -- n3 )
    : + ~~~~ ;

括号是forth的注释字，就像C语言里的//，强调一下，括号也是“字”，所以必须用空格隔开

`--左边`代表你要使用的栈单元，`--右边`代表使用之后去掉刚刚使用过的栈单元之后的变化。

为什么有这种用过就丢的设定？其实不是不能保留，但是从大多数情况来看，只需要用一次的情况居多，所以就选择了这种用过就丢的设定。

那么如果想重复使用同一个单元呢？forth提供了`dup(n -- n n )`、`over(n1[次栈顶]  n2[栈顶] -- n1 n2[次栈顶] n1[栈顶])`和`2dup( n1 n2 -- n1 n2 n1 n2  )`

例如，显示两次`3 dup`

其余两个字自己去试

##第8章 条件判断

forth的`if( n --  )`依然是反人类的，具体情况如下

    [条件] if  [真情况] else [假情况] then

例子（注：eforth的系统命令都是大写字母）

    ( n --  )
    : test if ." true" else ." false" then ;
    1 test
    2 test
    0 test 
    
测试结果是0为假情况，非0为真情况

一直忘了说，冒号是把 test 这个字加入词典，但并不执行。另外，需要执行的语句不需要加上分号。

`."`是一个字，所以必须用空格隔开后面的内容。不按这个标准来，forth就会告诉你：“我的词典里根本就没这个字”

在字写入词典之后即可输入参数进行测试，这也是forth的优点之一——容易测试。

    (n1 n2 -- T|F )
    : <	~~~~~ ;
    forth提供了小于号<，比较栈顶两个单元大小
    如果n1<n2 ，则换上一个-1（非0，TRUE，真）
    如果n1不<n2， 则换上一个0（0，FALSE，假）

再试试上面的那个test

    3 5 < test

forth还提供了一个swap( n1 n2 -- n2 n1 )，用于交换栈顶和次栈顶

    3 5 swap < test

现在我想从两个数里挑出比较小的那个

    ( n1 n2 -- n )
    : min	2dup < if drop else swap drop then ;

你来写一下`max`吧



##第9章 平方

加减乘除我们都会了,现在来看平方。

    例如：3^2

    写法1：3 3 *

    写法2：3 dup *


现在我想定义一个字，让它计算某个不确定的变量的平方，格式是`x square`。

    ( n -- n' )
    : square	dup * ;
    x square

现在我需要一个字`cube`来计算`x`的立方，由你来写

完成之后验算一下是不是对的。另外，你写了注释没？没吧？以后记得首先写注释，养成好习惯！

再求5次方，再验算，最后思考一下100次方应该怎么写


##第10章 for

上一章想过怎么写100次方了吧？有没有想起那个古代某自作聪明的小孩学了“一” “二” “三”就开始写“万”的故事？你没步他的后尘吧？

现在来介绍一下

    ( n --  )
    for...next

    : typetext 1000 for ." 露珠湿沙壁,暮幽晓寂寂" next
    这条语句会显示1000个"露珠湿沙壁,暮幽晓寂寂"

那么100次方怎么写？答案在本章结尾


100次方答案

写法1：

    ( x n -- x' )
    : cifang    1 - dup >r      ( x n --  x  n-1 )
                for dup next    ( x  n-1  -- x x x x x x x x x x x .....)
                r> for * next ; ( x x x x x x x x x x x ..... -- x' )
    x 100 cifang
    （你见过摩天大楼吗？我不但见过，还亲手盖了一座，用栈单元）


写法2：（这个就很省stack了，只给个提示，用`over`）


记住，写forth程序的时候，心里一定要有两个堆栈。


##第11章 核心词

核心词是forth中用其他语言（例如汇编、c等等，如果你不用考虑速度问题，还可以用其他高级语言）编写的字，构成形式与forth的语法完全不同，而扩展词则是用核心词组合而来。所以，扩展词只跟核心词的名字和与名字相应的功能有关，与编写核心词的语言无关，这也是forth容易移植的原因，你只需要重新编写几十个核心词，就可以快速的移植。

核心词分类

	计算：    um+  um*  um/mod  u<  1+ 1- 2* 2/
	逻辑计算：and or not xor 
	堆栈操作：>r  r> drop dup swap 
	内存读写：! @ c! c@
	系统相关：push execute exit sp@ sp!
	输入：key?
	输出：emit 
	退出：bye

以上是一些常见的核心词，各个版本的forth选定的核心词数量不一，各自有各自的考虑，这也是forth自由与混乱的源头。核心词相对较多，运行速度也就相对较快，核心词越少，运行速度越慢，传说曾经有人做了一个只有13个核心词的forth，速度就不用提了。有时候为了提高速度，也会把某些扩展词编写成核心词。

玩过积木吗？虽然积木只是一种结构简单的东西，但也有牛人能把这种简单的东西玩出花儿来。下面我们要玩的扩展词就类似于积木了。




在此，我给出

    >r ( n -- )  
	r> ( -- n ) 
	drop ( n -- ) 
	dup ( n -- n n ) 
	swap ( n1 n2 -- n2 n1 )
	
这几个核心词，你要做的就是用这几个字组合出下面所要求的字。答案是不给的，但是你不妨把你的答案发到讨论贴上让大家看看。再强调一次，一个合格的forther，心里一定要有两个堆栈

例子

	( n1 n2 -- )
	: 2drop	drop drop ;
	
你的积木

	( n1 n2 -- n1 n2 n1 )
	: over

	( n1 n2  -- n1 n2 n1 n2  )
	: 2dup

	( n1 n2 -- n1 n1 n2 )
	: dups

	( -- n ) ( "复制"返回栈的栈顶单元到数据栈 )
	: r@

	( n -- n)  ( "复制"数据栈的栈顶单元到返回栈 )
	: r!

	( n1 n2 -- n2 ) 
	: drops

	( -- )( 丢弃返回栈栈顶单元 )
	: dropr

	( n1 n2 n3 -- n2 n1 n3 )
	: swaps

	( n1 n2 n3 -- n2 n3 n1 )
	: rot

forth的基本内容至此就告一段落了，其中还有一些内容没怎么提及，例如`！ @  c！ c@` ，不确定次数的循环等等。没有详细说明是因为，一是暂时用不上，二是种类杂了。所以我就偷个懒，给你一个扩展阅读的机会，去参考其他的资料，例如《starting forth》。至于以后的篇章，与目前讲到的内容联系得不是很紧。

