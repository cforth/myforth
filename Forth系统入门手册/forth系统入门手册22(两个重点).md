##第22章 两个重点 

forth曾经被称为只写语言（write-only），写完之后甚至连作者本人都读不懂。其实forth程序是可以变得易读的，只要你能遵循下面两个重点。


###第1个重点：命名 
     
----------------------------《forth的禅思》---------------- ---------- 

好的 Forth 程式命名的原则 
选择好的指令名称，使程式易读，以下是好的Forth 程式命名的原则 

    (一)使用有意义的英文字。 

    (二)不要缩写。 

    (三)使用复合字如CountEggs , InitDataArray 名字可有31 个字。 

    (四)使用描述指令做什么的名字，让指令码解释它如何做事。 

    (五)不要例举像DataAray1,DataArray2 等，给予功能的描述像TemperatureArray , PressArray 等。 

    (六)指令码分解成短的片语并加以注解。 

    (七)定义短的定义并使重覆使用他们以提高词汇的再使用能力。 

    (八)在新定义里避免加入内部回圈的巢状结构。 

     (九)对输入和输出堆叠(Stack)项目，时时加以注解。 

    (十)在一个档里组成相关连的指令。 



----------------------------《Thinking Forth》---------------- ---------- 
 
垂直格式对水平格式 

注解的目的，在使程式码的读者容易看出正在进行的是什么事。但是，需要多少注解才 够？要决定什么样水平的注解才能满足需要，你必须问自己两个问题： 

谁会来读我的程式码？我那些定义的可读性如何？ 

注解的文体（styles）基本上有两种可供选择。第一种称为"垂直格式"，其中包含对过程的逐步叙述，就像是做了很好的注解的组合语言程式列表。这种逐步条列的注解称为"叙事式的注解"。 

```FORTH
  \ CRC Checksum
  : ACCUMULATE   ( oldcrc char -- newcrc)
     256 *                   \ shift char to hi-order byte
     XOR                     \ & xor into previous crc
     8 0 DO                  \ then for eight repetitions,
         DUP 0< IF           \ if hi-order bit is "1"
            16386 XOR        \ xor it with mask and
            DUP +            \ shift it left one place
            1+               \ set lo-order bit to "1"
                ELSE         \ otherwise, i.e. hi-order bit is "0"
            DUP +            \ shift it left one place
                THEN
         LOOP ;              \ complete the loop
```

另一种不在程式码的片语之间点缀这些叙事式注解的型态称为"水平格式"。 

```FORTH
      : ACCUMULATE ( oldcrc char -- newcrc) 
          256 * XOR 8 0 DO DUP 0< IF 
            16386 XOR DUP + 1+ ELSE DUP + THEN LOOP ; 
```

垂直格式适用于一大组程式设计师共同撰写及维护一个应用程式的情况。一般而言， 在这样的一组人中，有几个资浅的设计师负责次要的修正工作。在这样的环境下，费一番心力所做的注解总会节省下大量的时间，并且避免不少的困窘。 Moore产业公司的Johnson说：「当维修程式码时，你通常只会对其中的一小段有兴趣，写在那儿的资讯越多，尽快修复的机会也就越大。」 以下为该公司要求符式程式设计师遵守，且颇合要领的规则。 

1. 使用垂直格式。注解写在原始码的右方。有需要时，也可以接续到下一行。 
2. 注解所用的字数应该比原始码多。 （这个公司鼓励使用较长的、能充分描述意思的名字） 
3. 任何条件结构的字、或应用程式的字，应该分开写在另一行。 "噪音字"可以聚拢 在一起。在巢式的条件句中必须使用缩排。 （译注：在符式的核心字中，有些字会妨碍程式的可读性，如堆叠操作的DUP、DROP等等，它们看来就像是"噪音"） 



但是，这种格式也有其若干困难。至少，逐步叙述的注解方式很费时，即使你使用一个相当好用的编辑器也是如此。生产力会受到影响，尤其是当你停下来写注解而打断了你的思路时。同时，你也要小心翼翼地确保注解的更新。常有的情形是，程式码被修改了，修正的版本也经过测试，修正的部份也的确能工作--但是程式设计师却忘了去修改注解。注 解越多，它们就越有可能是错的。如果它们是错的，那可比没有注解还要糟。如果计划的负责人能够费心地检查以确保注解的正确性，那么问题还是可以解决的。最后，逐步注解的作法会给人一种虚假的安全感。别以为每行都有一个注解，就表示这个应用程式的注解就是好的。逐步注解并不会指出一个定义运作的精华。例如，所使用的检查值演算法（checksum algorithm）背后的想法是什么？谁又能从它的叙事式注解中看出什么来？要想妥当的描述一个已知程序的纠结过程，通常需要许多段落，而非单一个片语就能成事。这类的描述应该归属在补助文件或章节的前言中。撇开这些警告不提，仍有许多公司发现垂直式的注解是必要的。当然，一个刚开始采用符式的工作小组应该要去调适它，就如同任何一个大型的工作小组一样。水平格式又如何？或许这是个艺术对实际的话题，但是我忍不住要为水平的格式辩护。它同样地有效，甚至有些方面更杰出。如果符式程式码写得到家，就不会有含糊笼统之处。这意思是说： 

支援的词集有良好设计的语法 

    堆叠的输入输出均已注解 
    目的也做了注解（如果从名字或堆叠注解都不能清晰的说明时） 
    定义都不太长 
    传送到单一个定义的堆叠引数都不多（参阅第七章中"合乎体裁的堆叠"） 

无论如何，符式与其它语言的确是不同的。逐步注解的作法，不过是用来提高程式可读性的一些事物之一而已。细腻撰写的符式程式码有如诗歌，其所含有的精确意义，是程式设计师和机器二者都容易阅读的。你的目标应该是：撰写不需注解的程式码，即使你决定要为它们做注解。设计你的应用程式时，要让程式码--而非注解-- 表达出你的想法。如果你成功了，那你就摆脱了过度注解的纠缠，臻于言简意赅，了无瓜葛的境界。 

    ───────────────────────────────────── 
    提示最精确、最不浪费的说明文件就是能够自我说明（self-documenting）的原始程式码。 
    ───────────────────────────────────── 


除了对数学的嗜好外，若能确实地掌握自己的母语，对一位胜任的程式设计师而言， 不啻是万贯家财。 --（Edsger W. Dijkstra教授[3]） 

我们曾经讨论过，以名字来象征概念及事物这件事，在应用程式中的重要性。命名已变 成设计过程中的重要部份。新进人员总会忽略名字的重要性，他们认为「毕竟，电脑就是电脑，它并不在乎我选用的是什么名字。」 但是问题是，你在乎。好的名字对可读性是很重要的。甚至于，呼叫一个「单一个字的描述」（one-word description）这种心智上的锻炼，能在你的理解力上产生一种连锁反应，让你了解那个实体该做什么，不该做什么。以下是一些选择好名字所用的规则： 

    ───────────────────────────────────── 
    提示命名要根据"做什么"（what），而非"如何做"（how）。 
    提示 要选用那最有诠释力的字。 
    ───────────────────────────────────── 

『I'M』的选择是Moore的另一项发明，他说： 

我讨厌『LOGON』这个字。英文中没那种字。我当时正在找一个能表达"I'M.... "句子的一个字。它是个自然的字。我不过是在跨步时碰巧踢到了它。虽然中间那一点不太体面，但它却给人正确的感觉。所有这些小不点的字都是得到那一声"阿哈！"反应的康庄大道。如果你盼望的是个正确的字，很显然地，它就是那个正确的字。如果你所知道的辞汇很充裕，那你就是在一个能够选择正确字的较好位子上。 

    ───────────────────────────────── 
    另一个Moore所喜欢的字是『TH』，那是他用来做阵列索引的字。例如下面的片语 
        5 TH 
    会传回阵列中第五个（fifth ）元素的地址。 
    ───────────────────────────────────── 
    提示选择能在片语中表示出意义的那些名字。 
    ───────────────────────────────────── 



另一方面，Moore也指出，不恰当的名字可以一变而成为防止偷窥的简单技巧。当你迫不得已，非要公布你的原始码时，为了安全，大可以故意地去选择一些误导的名称，使你的程式码变得非常难读。当然，修改也就变得不可能了。 

    ───────────────────────────────────── 
    提示 拼出名字的全名。 
    ───────────────────────────────────── 

在一本杂志上，我曾读到一份符式程式码，那位作者似乎是见不得母音字母，例如『DSPL-BFR』，那是"DISPLAY BUFFER"的意思，看起来眼睛发酸。有的作者似乎迷信三个字母就能使尽天下魔术的手法，例如LENGTH 摇身一变而成LEN 。这些作法都反映出久远年代中的一些想法。符式字应该是要完全拼出来的。键入INITIALIZE 或TERMINAL 或BUFFER ，心里要感到骄傲。这些才是你所要表达的。使用缩写时最糟的事就是，你忘了当初是如何缩写的，到底是DSPL 还是DSPLY ？另一个问题是缩写有碍可读性。任何撰写程式用的语言，就算你不将写程式的困难算在内，就已经是够难读的了。 

    ───────────────────────────────────── 
    提示用连字符号所组成的名字可能意味着不良的分解。 
    ───────────────────────────────────── 

Moore说： 

在符式社团中，程式写作所用的文体是相当分岐的。某人使用连字符号将许多英文字连为一个字，以表达这个字要做的是什么。你将一大堆字长长地串接在一起， 就得到某种可读的东西。但我会立刻怀疑，程式设计者是否想过该将这些字打散开来，分别地为每个字下定义。那不是经常都能办得到的，也不是经常会是有益处的。但我总怀疑，连字符号组成的字是否已将两种概念搅和在一起。 

请比较下面同一件事的两种策略： 

    ENABLE-LEFT-MOTOR		LEFT MOTOR ON
    ENABLE-RIGHT-MOTOR		RIGHT MOTOR ON
    DISABLE-LEFT-MOTOR		LEFT MOTOR OFF
    DISABLE-RIGHT-MOTOR		RIGHT MOTOR OFF
    ENABLE-LEFT-SOLENOID	LEFT SOLENOID ON
    ENABLE-RIGHT-SOLENOID	RIGHT SOLENOID ON
    DISABLE-LEFT-SOLENOID	LEFT SOLENOID OFF
    DISABLE-RIGHT-SOLENOID	RIGHT SOLENOID OFF

左列的语法必须用到字典中的8个字；右列语法仅需6个--而且其中一些字，还很可能会在应用程式的其它部份再被使用到。如果你同时还有一个『MIDDLE』的马达及电磁阀，你就仅仅需要7个字来描述出16种组合。 

    ───────────────────────────────────── 
    提示 不要把数字捆在名字中 
    ───────────────────────────────────── 

小心那些用数字开头或结尾的名称，例如1CHANNEL，2CHANNEL，3CHANNEL等等。像这种名字跟数字捆在一起的情形，很可能是拙劣分解的征候。其犯的罪过与连字符号相同，祗是这时需要被分解出的是数值而非字。上列名称的较佳分解作法是 

    1 CHANNEL 
    2 CHANNEL 
    3 CHANNEL 

在这种情形下，三个字摇身一变而缩减为一个字。通常，名字与数字相捆就表示含混的命名。 


###第2个重点：因子化 


----------------《1x Forth 》（forth的创始人Moore）----------------- 
      
我不断在问， Forth 是什么？ Forth 是高度因子化的代码。我不知道除了说Forth 是定义之外还能说什么。如果你有了许多短小的定义，那你就是在编写Forth 程序。堆栈并不流行，我很奇怪为什么它没有流行。许多压力来自于既得利益者，他们不喜欢堆栈，他们喜欢寄存器。堆栈并不是能够解决所有问题的一个概念，但它的确非常非常有用，特别是对于信息隐藏，并且你需要两个堆栈。 

这里有一个程序员相关的问题，也可能是与所有程序设计都有关的问题：我们给一个子程序输入了太多的参数。看看许多 C 语言程序，它们很可笑。程序中的每件事情都通过调用序列传递，而子程序只是一个哑巴。 

如果你这样坚持做下去，能够实现更彻底的因子化。这是我头脑中的Forth 的关键，你因子化、再因子化、再因子化，直到你的大多数定义都只有一行或者二行长。 

你因子化、因子化、因子化、因子化，你扔掉了所有不使用的东西、不合理的东西。 Forth 的全部在于你不能用Forth 来编写程序，而是用Forth 来编写字典。当你设计一个应用的时候，你写出100 个左右的字，它们可以描述应用，然后你使用这100 个字写出一行定义来解决应用的问题。找到这100 个字并不容易，但它们是存在的，它们总是存在的。 



----------------------------《ThinkingForth》------------------- ------- 

将控制结构分解出来 

这里有二个定义，它们的差异存在于一个『IF THEN』的结构内： 

    : ACTIVE   A B OR  C AND  IF  TUMBLE JUGGLE JUMP   THEN ;
    : LAZY     A B OR  C AND  IF    SIT   EAT   SLEEP  THEN ;

其中的条件与控制结构都是相同的；只有要做的事不同。既然你不能分解『IF』到一个字而『THEN』到另一个字，那么最简单的方式就是分解出这个条件： 

    : CONDITION?   ( -- ? )   A B OR  C AND ;
    : ACTIVE   CONDITION? IF  TUMBLE JUGGLE JUMP   THEN ;
    : LAZY     CONDITION? IF   SIT    EAT   SLEEP  THEN ;

依这种相同的条件与控制结构重复出现的次数而定，你甚至可能想要将两者都分解出来。注意下面的做法： 

    : CONDITIONALLY    A B OR  C AND NOT IF  R> DROP  THEN ;
    : ACTIVE   CONDITIONALLY   TUMBLE JUGGLE JUMP ;
    : LAZY     CONDITIONALLY   SIT    EAT   SLEEP ;




分解的准则 

在对分解的技巧有所了解之后，现在让我们讨论一些分解符式定义的准则。它们包 含了： 

限制一个定义的大小2. 限制重复出现的码3. 命名的能力4. 资讯隐藏5. 简化"命令的介面" 

    ───────────────────────────────────── 
    提示 保持定义短小 
    ───────────────────────────────────── 

我们问Moore，「一个符式的定义应该是多长呢？」 

一个字的定义应该是一行长。那是目标。当你有一堆字，它们在自己的理由上全都是有用的--也许是在除错上、或为了探究事情，但不可避免的总有它们存在的理由-- 你能感觉到你已经撷取到了问题的本质，而这些字也正恰当的表达出它了。短小的定义会给你一种好的感觉。 
    


对Moore先生的一个应用程式所做的一项非正式的检查显示出，他在每个定义中，平均用到7个词和数值。这很明显地是一个短小的定义。 （实际上，在他的码中，一行的定义和二行的定义，分别占有约50％的比例） 心理学上的试验显示，人类的心灵同一时刻只能集中它的意识到七件左右的事情上[2]。但是，不分昼夜的，心灵的巨大资源却潜意识地储存下巨量的资料，并建立其间的关联，及解决问题。即使我们的潜意识心灵知道一个应用程式的每个部份，我们狭窄观点的意识心灵也只能同时使其中七个元素相关联。超过这点，我们的注意力就会动摇。短小的定义与我们心智的能力是相互吻合的。诱使很多符式程式设计师写出过度冗长的定义，部份原因是因为他们知道一个定义的"头部"会占用一些词典的空间。分解做的愈少，名字就愈少，记忆体的浪费也愈少。的确是会用去较多的记忆体，但很难说那些用来帮助你测试、除错和交谈的东西是一种"浪费"。如果你的应用程式很大，那么试着去使用"三个字元长度的命名"方式（但仍保留恢复使用全名的能力，以避免在特别情况下，名字上的冲突）。如果这样做之后，应用程式仍然太大。那么考虑转换到一个有延伸记忆体的多个词典的符式系统，或者另一个更好的方式，使用一个有32位元定址空间的符式系统。另一个相关的顾虑是，害怕过多的分解将会--因为符式内部解译器运作的时间耗费-- 造成性能上的降低。这点也是对的，每一层呼叫的确是要付出一些代价。但在正常状况下，经由适当的分解，这额外的呼叫所付出的代价是查觉不到的。如果执行速度的需求真的这么没有伸缩余地，那么真正的解决方式，还是应该把一些字改写为组合语言定义，才较为妥当。 

    ───────────────────────────────────── 
    提示在你对你的码感觉不确定的地方进行分解（在那里，事情的复杂度已经接近了意识上的极限）。 
    ───────────────────────────────────── 

不要让你的自傲站出来说：「虽然复杂，但我还是能以这样地方式来解决它！」。符式码绝不应该让人感受到那种令人不快的复杂度。分解它！ 

Moore说： 

进行分解的情况之一是当你感觉好像会引入一个错误时。祗要看到一个双层的『DO LOOP』结构出现，那就是一个"不对劲了"的警示，因为它将是难以除错的。我几乎一定会将内层的『DO LOOP』回路分解出来成为一个字。为了测试的目的而分解出来的字，没有理由再将它塞回去。你在它第一次出现的地方发现，将它分解出来是个正确的做法。没有人能保证你不会再次地需要它。 
    

这里是同一个原则的另一面： 

    ───────────────────────────────────── 
    提示 在似乎需要做注解的地方分解。 
    ───────────────────────────────────── 

特别是当你感觉好像需要提醒你自己有些什么东西在堆叠上时，这或许正是"断开来"的好时机。假设你有 

    ... BALANCE DUP xxx xxx xxx xxx xxx xxx xxx 
    xxx xxx xxx xxx xxx ( -- balance ) SHOW ... 

这段码以计算帐目的平衡开始，并以显示它做为结束。在其间，同时另有几行码，因为需要而使用着这个平衡值。能够看出当『SHOW』执行时，这个值还仍然留在堆叠上，并不容易，所以程式设计师就插入一个堆叠注解。这样的解答通常代表着一种不良的分解。比较好的写法是： 

    : REVISE ( balance -- ) xxx xxx xxx xxx xxx xxx xxx 
    xxx xxx xxx xxx xxx xxx ; 
    ... BALANCE DUP REVISE SHOW ... 

它不需要叙事式的堆叠图画。而且，程式设计师现在有了一个可以再度使用的、可被测试的副定义。 

    ───────────────────────────────────── 
    提示 限制程式码的重复。 
    ───────────────────────────────────── 

分解的第二个理由--消除程式码的重复段落-- 这要比减小定义的尺寸更为重要。 


Moore说： 

当一个词只是一堆东西的时候，它对程式在意思上的清晰度、或者除错上的方便，虽然是有用的，但总比不上那种能被多次使用的词那么好。一个词若是只被使用一次， 你就该考虑它是否值得存在。有许多次，当一个程式的尺寸变得太大的时候，我就回头寻找那些会引起我的注意的片语，看看是否能够将它们分解出来。电脑做不了这件事；因为其中有太多的变数。
    


在回顾你的工作时，你经常能发现相同的片语、或重复出现了好几次的词句。在我写一个编辑器时，我发现下面这个片语重复出现了好几次： 

    FRAME CURSOR @ + 

因为它出现了好几次，所以我将它分解出来成为一个新字『AT』 。你自己要能分辨出那些写出来不同，但功能上却是相同的码，例如： 

    FRAME CURSOR @ 1- + 

其中『1-』的出现使这个片语看似不同于『AT』的定义，但事实上，它能被写成： 

    AT 1- 

另一方面： 

    ───────────────────────────────────── 
    提示当分解出重复的码时，要确定这个分解出的码只具有单一目的。 
    ───────────────────────────────────── 

不要盲目地抓住那些重复的东西，它们也许没什么用处。例如，在某一个应用中的一些地方，我使用到下面的片语： 

    BLK @ BLOCK >IN @ + C@ 

我把它定义为一个新字『LETTER』，因为它传回被解译器所指着的字母。在一个稍后的版本中，我意外地必须写出： 

    BLK @ BLOCK >IN @ + C! 

我无法使用已经存在的『LETTER』，因为此处不是以『C@』做为结束。我不愿在新版本中重复的使用这一大块的片语，而选择重新将『LETTER』分解的更细致些--把『C@』拿出来。然后，用法就变成了是『LETTER C@』或者『LETTER C!』。这个改变需要我搜寻整个程式，找出所有出现『LETTER』之处，并以『LETTER C@』来取代它。我应该在一开始就做对它，要将"地址的计算"与"对这个地址的运作"这二件事分开来。类似于我们对抗重复码的情况是： 

    ───────────────────────────────────── 
    提示 寻求重复的式样（pattern）。 
    ───────────────────────────────────── 

假如你发现你自己在参考先前程式中所写的某些部份，并将它们拷贝来使用，那么你也许已将一个特定的应用混在一个平常的看法之中。你所拷贝的那份式样也许可以分解出来， 作为一个独立的定义，而被使用在所有类似的情况中。 

    ───────────────────────────────────── 
    提示要确定能为分解出的部份取个名字。 
    ───────────────────────────────────── 

   
Moore说： 

假如你有一个概念，但是却不能给它一个单一的名字（不是指那种用连字符号连接着的复合名称），那么它就不是一个"恰当成形"的概念。拆解（decomposition）的要件之一就是有命名的能力。这样，当然你就会对你的概念更具信心。 


把这个观点与第一章中"结构化设计"所提出的模组拆解的准则做一比较。根据那个方法， 一个模组将展现"功能性的组合"，而这点是可以经由能够使用单一的、非复合性的句子，来描述出它的功能而得以验证。符式的"原子"，一个名字，更具有10倍以上的细致。 

    ───────────────────────────────────── 
    提示分解定义，以便隐藏"可能被改变的细节"。 
    ───────────────────────────────────── 

在前几章中，我们已经看到了资讯隐藏的价值，特别是在初步设计的阶段。在实现阶段中，能够记住这个准则，也是很有帮助的。下面这个非常短的定义，它除了隐藏资讯之外，几乎没做什么事： 

    : >BODY ( acf -- apf ) 2+ ; 

这个定义允许你不用依赖字在字典中的实际结构，而就能将一个"执行码区"的地址（address of code field）转换为一个参数区地址（address of parameter field）。如果你在程式中使用了『2+』而不是『>BODY』，那么当程式需要转移到一个字的头部（header）与身部（body）是分开的符式系统时，你将失去移转性。 （这是Kim Harris 所建议的一套字--它被包含在符式83标准的一个实验性提议中[3]-- 其中的一个字）。下面是一群可能被用来写出一个编辑器程式的定义： 

    : FRAME ( -- a ) SCR @ BLOCK ; 
    : CURSOR ( --a ) R# ; 
    : AT ( -- a ) FRAME CURSOR @ + ; 

这三个定义形成了所有为了移动文句所需的位址的计算基础。经由它们，你可以将编辑上的演译法从对符式区块（blocks）的依赖完全地分开来。这有什么好处？万一在发展的过程中，你决定要建立一个编辑缓冲区，以保护使用者不小心犯错时，不会毁掉区块内的资料。你只需重新定义其中的二个词，或许像这样： 

    CREATE FRAME 1024 ALLOT 
    VARIABLE CURSOR 

其余的码可以完全不做任何修改。 

    ───────────────────────────────────── 
    提示从显示结果的定义中，分解出计算它的演绎法。 
    ───────────────────────────────────── 

它其实是个属于拆解上的问题。这里有个例子。下面这个词，读做"people-to-paths"，是用来计算出一群人之间所有可能的通讯路径的数量。 （这是一个程式设计小组的经理人员所需要知道的好东西，通讯路径的数量会随着每个新组员的加入而快速的增加。） 

    : PEOPLE>PATHS ( #people -- #paths ) DUP 1- * 2/ ; 

这个定义只是做计算。下面这个"使用者的定义"会呼叫『PEOPLE>PATHS』去进行计算， 然后再将结果显示出来： 

    : PEOPLE ( #people -- ) ." = " PEOPLE>PATHS . ." PATHS" ; 

这就会产生： 

    2 PEOPLE = 1 PATHS 
    3 PEOPLE = 3 PATHS 
    5 PEOPLE = 10 PATHS 
    10 PEOPLE = 45 PATHS 

即使你认为，你只是要做一个特殊的计算，而且就祗一次而已，然后再以一种方式显示其结果。相信我，你是错的。你将来还是会需要再回过头来，将做计算的部份分解出来。也许是为了要能以右边对齐的方式显示这个资料，也许是为了要将结果记录在一个资料库内，你不可能事先知道。但是，既然你早晚是要分解它的，何不在第一次就做对这件事。 （不值得为了那些少数的、能免除这项需要的情况，而引进这种麻烦。） 『. 』是一个基本的例子。 『.』在大约99％的时候，都是很不错的，但是它偶尔是做的太多了些的。事实上，它所做的是（在符式83'中）： 

    : . ( n--) DUP ABS 0 <# #S ROT SIGN #> TYPE SPACE ; 

假设你想要将一个堆叠上的数值转换为一个ASCII字串，并且将它储存在一个缓冲区内， 等待稍后再印出。 『.』会转换它，但却也会印出它。或者假设你要以"10C"的格式来编排纸牌，你不能用『.』来显示这个10，因为它会在后面加上一个空格。 

在有些符式系统中，你能发现到一种较好的分解： 

    : (.) ( n -- a # ) DUP ABS 0 <# #S ROT SIGN #> ; 
    : . ( n --) (.) TYPE SPACE ; 

我们在第四章的罗马数字的例子中，发现另一个未能将计算功能自输出功能中分解出的例子。在我们的解答里，我们不能将一个罗马数字存到一个缓冲区内，或什至于以中间对齐的方式印在一个栏位中。一个较好的方式是使用『HOLD』代替『EMIT』。 ） 有时也可能为了"资讯隐藏"，而不去做分解。例如，如果你分解出这个片语 

    SCR @ BLOCK 

成一个定义 

    : FRAME SCR @ BLOCK ; 

要记得，你之所以这样做，只因为你为了可能要改变编辑的框架（editing frame）的位置。不要盲目的将所有这样出现的片语都以『FRAME』来取代，因为稍后你可能会需要改变『FRAME』的定义，而程式中也有真正需要使用『SCR @ BLOCK』的地方。 


提示假如一个重复出现的片段，在有些地方看来像是会改变，但有些却不会变，那么就只分解出那些可能会改变的地方。如果这个片段可能有好几种改变的方式，就将它分解为不同的定义。 


想要知道何时该隐藏资讯是需要直觉和经验的。在你的生涯中经历了许多设计规格的变更之后，你就会学到，事情在将来总是倾向于要被改变的。当然，你是绝对无法预测到每件事的。做这样的尝试将会是徒劳无功的，就如我们将在后面的"在实现阶段中的反覆作为"一节中所见。 



    ───────────────────────────────────── 
    提示 不要为了分解而分解。使用原本的陈腔滥调（cliches）。 
    ───────────────────────────────────── 

这个片语 
    
    OVER + SWAP 

在一些应用中很常见。 （它转换一个地址与计数值为一个结束地址与起始地址，以适合『DO LOOP』的结构使用。） 另一个常用的片语是 

    1+ SWAP 

（它将"第一个索引值"及"最后一个索引值"的顺序重新安排为"最后一个索引值加一" 及"第一个索引值"的新顺序，以供『DO』这个词所需。 ） 把这些片语分解出来做成一个词，像是『RANGE』（前面那一个片语），是有些令人心动。 


Moore说： 

那个特别的片语『OVER + SWAP』就恰在"是否要成为一个有用的词？"的边缘上。经常的，你把某一些东西定义成一个词，而结果是你只使用它一次。如果你把这样的一个片语定出名字，你会很难记住『RANGE』确实做了什么。在你的心中，你看不到 这个操作。 『OVER + SWAP』片语比起『RANGE』这个词有较大的助忆性（mnemonic value）。 


我称这类片语为"陈腔滥调"。他们黏在一起，以表示一种有意义的功能。你不必去"记住" 这个片语是如何工作的，只要记住它做了什么就好了。而且你也不需要再多记一个额外的名字。 

    ───────────────────────────────────── 
    提示 不要一次改正太多。 
    ───────────────────────────────────── 

当你在编辑你的应用程式时--加上一个新的功能或者修正一些地方-- 经常会被诱惑着一次就把它们同时都做完或改正过来。我们的忠告是：不要这样做。在每个「编辑--编译」的循环中，在你能接受的范围内，尽可能地少做改变。在你继续下一步之前，要确定测试过了每个修正后的版本。你会惊讶，在做了三个看似简单的修改，再重新编译之后，竟然发现没有一个是能正确工作的，而这种情况却经常的发生。一次只做一个改变，就能保证当事情不对的时候，你知道原因何在。 

    ───────────────────────────────────── 
    提示不要尝试着太早去预设分解的方式。 
    ───────────────────────────────────── 

有些人奇怪为什么大部份的符式系统都没有定义一个阵列的词。这条规则就是理由。 

Moore说： 

我经常有阵列这种等级的东西。最简单的阵列只是付予一个地址一个标记，而这个标记会传回这个地址给你。你能像下面这样地定义出一个阵列 

    CREATE X 100 ALLOT 

然后说 

    X + 

或者你能说 

    : X X + ; 

最困扰我的一个问题是，是否值得为那个特别的资料结构做出一个定义字来？我会有足够多的地方来使用它，而使我那多付出的工作变的值得吗？我很难事先知道将来是否会需要超过一个以上的阵列。所以，通常我并不定义 ARRAY 这个字。当我发现我需要二个阵列之后，问题就在边缘上了。假如我需要三个，那么答案就很清楚了。除非他们是不同的。而经常地，他们却真 是不同的。你可能需要它为你取得内容，你也可能需要字元的阵列，或位元的阵列。你可能想要做上下限的检查，或存下它目前的长度以便你能加上东西到它的尾端。我咬紧牙根并且说，「我应该将这个字元阵列做成一个胞元（cell）阵列，以便能让这个资料结构适用于我现在已经有的词吗？」 问题愈复杂，你就愈不容易找到一个能适用的一种通用型的资料结构。一个真正复杂的资料结构，能够被普遍地使用着的机会是很小的。一个成功的这种例 子是符式的词典。它的结构坚固，又很有弹性。它在符式里到处被使用着。但是这 种例子毕竟少见。如果你选择去做出阵列的定义字，其实你就是完成了一个分解的步骤。你已经从将来所有会包含阵列的字中，分解出阵列这个概念。你已经到达了另一层次的抽象。建造抽象的层次是一种动态的过程，它不是你能事先预知的。 

    ───────────────────────────────────── 
    提示 今天，让它能工作。明天，再将它最佳化。 
    ───────────────────────────────────── 
    
在有一天和Moore的面谈中，那时他已经完成了一个电路板级（board level）的符式电脑的设计，它使用一般市面上现成可用的IC来组成。做为设计那片板子的工具箱的一部份，他用符式建了一个模拟器，来测试板子上的逻辑电路： 

直到这个早上我才认识到，我一直将"对晶片的描述"与"对这些晶片在板子上的配置的描述"混在一起。在当时，它非常的方便于用来达到我的目的，但是当我要在另一片板子上使用这些相同的晶片时，才发现到我把事情安排的很糟。我应该将对晶片的描述与对晶片的使用分解到不同的地方。这样我就会有一个晶片 描述语言了。好吧，也许是因为当我正在做这件事的时候，我对那种层次的最佳化并不感兴趣。即使后来这个念头曾经出现过，我也可能会说：「让我晚一点再去做这件事」， 然后就投入到我正在做的事情当中。在那时，最佳化对我来说并不是最重要的。当然，我会试着做出良好的分解。但是，如果在那时还看不出个好方法，我就会说：「先让它能工作再说」。我并不是懒惰，我只是知道将来会有一些东西以某种方式来影响这个决定，而怎么影响却是我现在无法预知的。现在就试着最佳化是愚蠢的。除非整个情况清楚地出现在我面前，我是无法知道那个最佳化应该是什么样子的。 


在这一节中所做的这些观察，是不会与在这之前所谈论的资讯隐藏和预测将来会改变的元素这些事相冲突的。一个好的程式设计师会不断地尝试平衡于「先花费时间来建构出具有接受变化性的事物」和「以后如果有需要，再花费时间来修改它」这二种选择上。做这些决定需要经验。但是，做为一个一般性的规则： 


提示要经由组织资讯（organizing information）来预测可能会变化的事物，而不是以增加复杂度来达成。只有在为了使目前的反覆周期能正确工作的需要下，才能增加复杂度。 

