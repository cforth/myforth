###第2节 编译模块

```FORTH
------------------------------------------------------------------
(  --  )
: 编译执行		缓冲区定位 dup 文本预处理 
			忽略空白字符 读取字符 
			冒号?  如果是 编译模式 否则 解释模式 ;

: 文本预处理

: 忽略空白字符

: 冒号?

: 编译模式

: 解释模式
------------------------------------------------------------------
( addr --  )
: 文本预处理	do 读取字符 
			dup if0 2drop break
			空白字符?  如果是 替换成空格 否则 drop 
			++ loop ;

( c  -- T | c F )
: 空白字符?

( addr -- addr )
: 替换成空格	push #32  储存字符 ;
------------------------------------------------------------------
( c  -- T | c F )
: 空白字符?	空格? case TRUE 
			tab? case TRUE 
			CR?  case TRUE 
			LF?  ;

( T|F  --  )
: case	r@ @ swap if execute break 
		drop r> cell+ >r ;

( c  -- T | c F )
: 空格?	push #32 对比字符 ;

( c  -- T | c F )
: tab?	push #9 对比字符 ;
------------------------------------------------------------------
( addr -- addr' )
: 忽略空白字符	do 读取字符 ++s 
			空格? 如果是 loop endif
			左括号?  如果是 忽略注释 loop 
			 -- break ;

( c  -- T | F )
: 左括号?	push #40 == ;
( c  -- T | F )
: 右括号?	push #41 == ;

( addr  -- addr'  )
: 忽略注释		do 读取字符 ++s 
			右括号?  如果是 break endif
			loop ;
------------------------------------------------------------------
( c -- T |  F )
: 冒号?	push #58 == ;
------------------------------------------------------------------
( addr --  )
: 编译模式		++ 忽略空白字符 
			新词条位置 复制词名> 连接词头 
			swap 忽略空白字符 分解语句 词典扩充 ;

( addr --  )
: 解释模式		新词条位置 连接词头 
			swap 分解语句 执行临时词 ;

: 新词条位置	词典目录尾 ;


( 源地址 目标地址  -- 源地址结尾空格外 目标地址结尾空格外  )
: 复制词名>	do  over c@ 空格?  如果是 复制字符> break 
			drop 复制字符> loop ;

( 目标地址 源地址  -- 目标地址结尾空格外  源地址结尾空格外 )
: 复制词名<	swap 复制词名> swap

( 源地址 目标地址  -- 源地址++ 目标地址++ )
: 复制字符>		over c@ 储存字符 ++s ;

( 目标地址 源地址  -- 目标地址++ 源地址++ )
: 复制字符<		swap 复制字符> swap ;
```

( 在x86的 jmp/call  label 这种机器码里,label是个相对地址值[其他类型的CPU不一定], 如果你想把jmp label复制到新词条里, 就必须计算[label:] 到 [jmp label] 之间的长度, 然后用当前的地址值加上或减去这个长度, 才能得出你需要的jmp label.  为了简化这个过程, 我的办法是耗费一个寄存器保存label的绝对值, 然后"jmp 寄存器" , 这就不是一个需要计算的相对值了, 它是个只占2个字节的机器码, 所以我可以直接复制过去 )

```FORTH
( 机器码地址 -- 机器码地址+词头长 )
: 连接词头	push 连接词头 @  ( 机器码地址 词头内容 )
		over ! 词头长+ ;

: 词头长+	 push $2 + ;

: 分解语句

: 词典扩充

: 执行临时词
------------------------------------------------------------------
( 机器码地址 文本地址 -- 机器码地址' )
: 分解语句		do 读取字符 
			分号? 如果是 结束分解 break 
			双引号? 如果是 编译成字串 loop 
			drop 词典目录尾 查找单词 
			下个单词 loop ;

( c --  T | c F )
: 分号?	push #59 对比字符 ;

: 编译成字串

: 查找单词	

: 结束分解		

: 下个单词		移到单词尾空格外 忽略空白字符 ;

( addr -- 词尾空格外 )
: 移到单词尾空格外	do 读取字符 ++s 
				空格? 如果是 break endif
				drop loop ;
------------------------------------------------------------------
( 机器码地址 文本地址 -- 机器码地址' 文本地址' )
: 编译成字串	++ do 读取字符 
			字串尾标记? 如果是 标记字串尾 break 
			复制字符< loop ;

( 文本地址 c -- 文本地址' T   |   文本地址 F )
: 字串尾标记?	双引号? 如果不是 setF exit 
			++ 读取字符 空格? 如果是 TRUE exit
			--s setF ;

( 机器码地址 文本地址 -- 机器码地址' 文本地址' )
: 标记字串尾	swap 标记字串尾0 swap 
			忽略空白字符 ;

( addr -- addr++ )
: 标记字串尾0	push #0 储存字符 ;
------------------------------------------------------------------
( 机器码地址 文本地址 词典串线地址 -- 机器码地址' 文本地址  | 堆栈重置 )
: 查找单词		do 词典下一词目
			dup? if0 没找到该词 break 
			2dup 词名相同? 如果是 编译该词 break 
			loop ;	

( 词典串线地址 -- 词典串线地址' )
: 词典下一词目	cell- @ ;

: 没找到该词

: 词名相同?

: 编译该词
------------------------------------------------------------------
( 机器码地址 文本地址 -- 机器码地址' 文本地址 |    输出错误单词并重置堆栈    )
: 没找到该词	push push 编入新词条 
			dup 数值? 如果不是 编译错误 exit
			转换成数值 编入新词条 ;

( 机器码地址 文本地址 n  --  机器码地址+cell 文本地址  )
: 编入新词条	swaps over ! cell+ swap ;

: 编译错误

: 数值?

: 转换成数值
------------------------------------------------------------------

( 文本地址 --  ) (  _resetStack是myforth.asm里的一个label )
: 编译错误		."  "["  .word  ."  "]?" cr 		
			 _resetStack ;
			 
(	myforth.asm
	......
org	COLDD
	mov ax,cs
	mov ds,ax
	mov ss,ax
	mov es,ax

_resetStack@:
	mov	sp,DSP
	mov bp,RSP
	mov di,doList@
	......
)

------------------------------------------------------------------
( 文本地址 --  16 T |  10 T |  F )
: 数值?		读取字符 美元号? 如果是 16进制? 否则 10进制? ;

( c -- T | F )
: 美元号?		push #36 == ;

: 16进制?	

: 10进制?
------------------------------------------------------------------
( 文本地址 -- 16 T |  F  )
: 16进制?		++
			do 读取字符 ++s
			16进制数字? 如果不是 16进制尾标记? break 
			loop ;

( c -- T | c F  )
: 16进制数字?	0-9? 如果是 setT exit  
			A-F? 如果是 setT 否则 FALSE ; 

( c  -- c T  | c  F )
: 0-9?	dup push #48 u< if FALSE exit 
		dup push #57 u> if FALSE else TRUE ; 

( c  -- c T  | c  F )
: A-F?	dup 转换成大写字母 
		dup push #65 u< if setF exit 
		dup push #70 u> if setF else setT ; 

( 文本地址 c -- 16 T |  F  )
: 16进制尾标记?	 空格? 如果不是 setF2 exit
			drop push #16 TRUE ;

( n1 n2 -- T )
: setT2	drops setT ;
( n1 n2 -- F )
: setF2	drops setF ;
------------------------------------------------------------------
( 文本地址 --  10 T |  F  )
: 10进制?		读取字符 负号? 如果是 ++ endif 
			do 读取字符 ++s 
			0-9? 如果不是 10进制尾标记? break 
			drop loop ;

( c -- T|F )
: 负号?		push #45 == ;

( 文本地址 c -- 10 T |  F  )
: 10进制尾标记?	 空格? 如果不是 setF2 exit
			drop push #10  TRUE ;
------------------------------------------------------------------
( 文本地址 n  -- num )
: 转换成数值	over 进制转换 over 负号处理 ;

: 进制转换

( num 文本地址 -- num' )
: 负号处理		c@ 负号? 如果是 negate endif ;
------------------------------------------------------------------
( n 文本地址 -- num )
: 进制转换		push #0 do 
			over c@ 空格? 如果是 2drops break
			>r >r over r> *
			r> 字符转换成数值 +
			++s loop ;

: 2drops		drops drops ;

( c -- num  )
: 字符转换成数值	0-9? case 转换成数字0-9
				A-F? case 转换成数字10-15 
				drop push #0 ;

( c -- num )
: 转换成数字0-9		push #48 - ;

( c -- num )
: 转换成数字10-15	 转换成大写字母 push #55 - ;
------------------------------------------------------------------
( 文本地址 词典串线地址 --  T |  F )
: 词名相同?	do  
			over c@ over c@ !=  if setF2 break 
			读取字符 空格? 如果是 setT2 break 
			drop ++ ++s  loop ;
------------------------------------------------------------------
( 机器码地址 文本地址 词典串线地址  --  机器码地址' 文本地址 )
: 编译该词		该词执行地址 编入新词条 ;

: 该词执行地址	移到单词尾空格外 ;
------------------------------------------------------------------
( 机器码地址 文本地址 -- 机器码地址+cell )
: 结束分解		push exit 编入新词条 drop ;
------------------------------------------------------------------
( 机器码地址  --  )
: 词典扩充		词典目录尾 over ! cell+ 更新词典目录尾 ;

( 机器码地址  --  )
: 更新词典目录尾	= 词典目录尾 ;

( num  --  )
: =		r@ @ 词头长+ cell+ ! 
		r> cell+ >r ;

: 词头长+		push #2 + ;
------------------------------------------------------------------
( 机器码地址  --  )
: 执行临时词	drop 新词条位置  execute ;
------------------------------------------------------------------
```

编译器的核心内容就是这些了,包括了输入,单词分割,搜索词典,找到时的编译,未找到时转换成数字或做错误处理, 以及整句编译完成后的执行或扩充词典, 现在你可以对刚刚提到的这些功能开始一个一个的测试了.


为了测试得更彻底,再加上两个输出的词

```FORTH
------------------------------------------------------------------
( n --  )
: .abs		push #0 swap 	余数分解 打印堆栈字串 ;

(  0 n -- 0 c1 c2 c3..... )
: 余数分解		do  push #10 /mod 
			push #48 + swap 
			dup if0 drop break 
			loop ;

( 0 c1 c2 c3..... --  )
: 打印堆栈字串	 do  dup if0 drop break 
			emit loop  ;
------------------------------------------------------------------
( n --  )
: .		负数处理 .abs space ;

( n -- n )
: 负数处理		dup negate? 如果不是 exit endif 
			negate push #45 emit ;
------------------------------------------------------------------
: .s		显示堆栈单元 ." " <TOP]" ;

: 显示堆栈单元	sp@ push #DSP cell-  
			do 2dup == if 2drop break  
			cell-  dup @ .  loop ;
------------------------------------------------------------------
```

    
我想,这些代码你应该看得比较顺溜吧, 你看得越顺溜, 也就代表我写得越费力, 费力就费力在对各个词的合适的命名和功能上的具体划分.  但这些力气也并不是白费的, 当我需要维护修改这些代码的时候, 会带给我更多的便利.

在写的时候,我都是先考虑每个词需要处理的参数和需要输出的返回值, 然后再动手写, 边写边在脑子里运行, 边运行边修改.  这倒不是我的脑子堪比电脑, 而是因为短小的定义更容易理解和除错

至于无法在forth编译器里输入中文的问题,可以采取折中的办法, 先写好一个代码文本,然后由forth编译器导入,再进行编译

以下是16位汇编的DOS功能调用(int 21h的那种), 有需要就自己写成核心词.
    
    │调用号│     功  能         │     入口参数         │     出口参数         │
    
    
    │  3CH │创建文件            │DS:DX=带路径的文件名  │CF=0 成功,AX=文件号   │
    │      │                    │CX=属性 1-只读 2-隐蔽 │CF=1 失败,AX=错误码   │
    │      │                    │        4-系统        │                      │
    

    │  3DH │打开文件            │DS:DX=带路径的文件名  │CF=0 成功,AX=文件号   │
    │      │                    │AL=方式 0-读 1-写 2-读│CF=1 失败,AX=错误码   │
    │      │                    │          写          │                      │
    
    
    │  3EH │关闭文件            │BX=文件号             │CF=0 成功             │
    │      │                    │                      │CF=1 失败,AX=错误码   │
    
    
    
    │  3FH │读文件或设备        │BX=文件号             │CF=0 成功             │
    │      │                    │CX=字节数             │DX:AX=新的指针位置    │
    │  40H │写文件或设备        │DS:DX=缓冲区首址      │CF=1 失败,AX=错误码   


forth系统入门手册到此结束，之所以说是入门手册，是因为我也还在学习中。这个系统并不是一个能在裸机上运行的操作系统，想要做到这种程度，还需要了解更多关于操作系统的知识。不过这些知识跟forth的连系就不是很大了，你需要的，是用forth的思想去运用这些知识。
